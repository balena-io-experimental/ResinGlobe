// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var BuiltinScope, Scope, ScopeLinter, defaultLinter,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BuiltinScope = require("./BuiltinScope");

  Scope = require("./Scope");

  module.exports = ScopeLinter = (function() {
    ScopeLinter["default"] = function() {
      return defaultLinter;
    };

    function ScopeLinter() {
      this.visitValue = bind(this.visitValue, this);
      this.visitTry = bind(this.visitTry, this);
      this.visitParam = bind(this.visitParam, this);
      this.visitOp = bind(this.visitOp, this);
      this.visitObj = bind(this.visitObj, this);
      this.visitFor = bind(this.visitFor, this);
      this.visitCode = bind(this.visitCode, this);
      this.visitClass = bind(this.visitClass, this);
      this.visitCall = bind(this.visitCall, this);
      this.visitAssign = bind(this.visitAssign, this);
      this.visitAssignment = bind(this.visitAssignment, this);
      this.visit = bind(this.visit, this);
      this.newScope = bind(this.newScope, this);
      this.newState = bind(this.newState, this);
      this.lint = bind(this.lint, this);
      this.scope = null;
      this.subscopes = null;
      this.reading = true;
      this.definitions = null;
      void 0;
    }

    ScopeLinter.prototype.lint = function(root, options) {
      var builtin, global;
      this.options = options;
      this.errors = [];
      try {
        builtin = new BuiltinScope(this.options["environments"], this.options["globals"]);
        global = new Scope(builtin, this.options);
        this.newScope(global, (function(_this) {
          return function() {
            return _this.visit(root);
          };
        })(this));
        this.errors.sort(function(a, b) {
          return a.lineNumber - b.lineNumber;
        });
        return this.errors;
      } finally {
        delete this.options;
        delete this.errors;
      }
    };

    ScopeLinter.prototype.newState = function(reading, definitions, cb) {
      var old, ref;
      old = [this.reading, this.definitions];
      ref = [reading, definitions], this.reading = ref[0], this.definitions = ref[1];
      try {
        cb();
        return void 0;
      } finally {
        this.reading = old[0], this.definitions = old[1];
      }
    };

    ScopeLinter.prototype.newScope = function(scope, cb) {
      var fn, i, len, old, ref;
      old = [this.scope, this.subscopes];
      this.scope = scope;
      this.subscopes = [];
      try {
        cb();
        this.scope.commit();
        ref = this.subscopes;
        for (i = 0, len = ref.length; i < len; i++) {
          fn = ref[i];
          this.newScope(new Scope(this.scope, this.options), fn);
        }
        this.scope.appendErrors(this.errors);
        return void 0;
      } finally {
        this.scope = old[0], this.subscopes = old[1];
      }
    };

    ScopeLinter.prototype.visit = function(node) {
      var handler;
      handler = this["visit" + node.constructor.name];
      if (handler != null) {
        handler(node);
      } else {
        node.eachChild(this.visit);
      }
      return void 0;
    };

    ScopeLinter.prototype.visitAssignment = function(destination, arg1) {
      var comprehension, ref, shadow, source;
      ref = arg1 != null ? arg1 : {}, source = ref.source, shadow = ref.shadow, comprehension = ref.comprehension;
      this.newState(false, [], (function(_this) {
        return function() {
          var i, len, name, node, ref1, ref2, results, type;
          if (destination.constructor.name === "Literal") {
            _this.definitions.push([destination.value, destination]);
          } else {
            _this.visit(destination);
          }
          _this.reading = true;
          if (source != null) {
            _this.visit(source);
          }
          type = "Variable";
          if (shadow) {
            type = "Argument";
          } else if (comprehension) {
            type = "Comprehension variable";
          }
          ref1 = _this.definitions;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            ref2 = ref1[i], name = ref2[0], node = ref2[1];
            results.push(_this.scope.identifierWritten(name, node, type));
          }
          return results;
        };
      })(this));
      return void 0;
    };

    ScopeLinter.prototype.visitAssign = function(node) {
      this.visitAssignment(node.variable, {
        source: node.value
      });
      return void 0;
    };

    ScopeLinter.prototype.visitCall = function(node) {
      var arg, i, len, ref;
      if (node["do"]) {
        if (node.variable.constructor.name === "Code") {
          this.visitCode(node.variable, true);
        } else {
          this.visit(node.variable);
        }
        ref = node.args || [];
        for (i = 0, len = ref.length; i < len; i++) {
          arg = ref[i];
          this.scope.identifierRead(arg.name.value, arg);
        }
      } else {
        node.eachChild(this.visit);
      }
      return void 0;
    };

    ScopeLinter.prototype.visitClass = function(node) {
      if ((node.variable != null) && node.variable.base.isAssignable()) {
        this.scope.identifierWritten(node.variable.base.value, node, "Class");
        if (this.definitions != null) {
          this.scope.identifierRead(node.variable.base.value, node.variable);
        }
      }
      if (node.parent != null) {
        this.visit(node.parent);
      }
      this.subscopes.push((function(_this) {
        return function() {
          return _this.visit(node.body);
        };
      })(this));
      return void 0;
    };

    ScopeLinter.prototype.visitCode = function(node, noShadow) {
      if (noShadow == null) {
        noShadow = false;
      }
      this.subscopes.push((function(_this) {
        return function() {
          var i, len, param, ref;
          _this.scope.identifierWritten("arguments", node, "Builtin");
          if (noShadow) {
            _this.scope.options["shadow"] = false;
          }
          ref = node.params || [];
          for (i = 0, len = ref.length; i < len; i++) {
            param = ref[i];
            _this.visit(param);
          }
          return _this.visit(node.body);
        };
      })(this));
      return void 0;
    };

    ScopeLinter.prototype.visitFor = function(node) {
      var comprehension, i, len, prop, ref;
      comprehension = true;
      ref = ["first_line", "first_column", "last_line", "last_column"];
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (node.locationData[prop] !== node.body.locationData[prop]) {
          comprehension = false;
          break;
        }
      }
      if (node.name != null) {
        this.visitAssignment(node.name, {
          comprehension: comprehension
        });
      }
      if (node.index != null) {
        this.visitAssignment(node.index, {
          comprehension: comprehension
        });
      }
      node.eachChild(this.visit);
      return void 0;
    };

    ScopeLinter.prototype.visitObj = function(node) {
      var i, len, prop, ref;
      ref = node.properties;
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (prop.constructor.name === "Assign") {
          if (this.reading || prop.context === "object") {
            this.visit(prop.value);
          } else {
            this.visitAssignment(prop.variable, {
              source: prop.value
            });
          }
        } else {
          this.visit(prop);
        }
      }
      return void 0;
    };

    ScopeLinter.prototype.visitOp = function(node) {
      var ref;
      if ((ref = node.operator) === "++" || ref === "--") {
        this.visitAssignment(node.first);
        return this.visit(node.first);
      } else {
        return node.eachChild(this.visit);
      }
    };

    ScopeLinter.prototype.visitParam = function(node) {
      this.visitAssignment(node.name, {
        source: node.value,
        shadow: true
      });
      return void 0;
    };

    ScopeLinter.prototype.visitTry = function(node) {
      this.visit(node.attempt);
      if (node.errorVariable != null) {
        this.visitAssignment(node.errorVariable);
      }
      if (node.recovery != null) {
        this.visit(node.recovery);
      }
      if (node.ensure != null) {
        this.visit(node.ensure);
      }
      return void 0;
    };

    ScopeLinter.prototype.visitValue = function(node) {
      var name;
      if (node.base.constructor.name === "Literal") {
        if (node.base.isAssignable()) {
          name = node.base.value;
          if (this.reading || node.hasProperties()) {
            this.scope.identifierRead(name, node);
          } else {
            this.definitions.push([name, node]);
          }
        }
        if (node.hasProperties()) {
          this.newState(true, null, (function(_this) {
            return function() {
              var i, len, prop, ref, results;
              ref = node.properties;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                prop = ref[i];
                if (prop.constructor.name !== "Access") {
                  results.push(_this.visit(prop));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            };
          })(this));
        }
      } else if (node.base.constructor.name === "Call") {
        this.newState(true, null, (function(_this) {
          return function() {
            return node.eachChild(_this.visit);
          };
        })(this));
      } else {
        node.eachChild(this.visit);
      }
      return void 0;
    };

    return ScopeLinter;

  })();

  defaultLinter = new ScopeLinter();

}).call(this);
