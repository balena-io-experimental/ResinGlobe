// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var Scope,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = Scope = (function() {
    function Scope(parent1, options) {
      var key, value;
      this.parent = parent1;
      if (options == null) {
        options = {};
      }
      this.appendErrors = bind(this.appendErrors, this);
      this.commit = bind(this.commit, this);
      this.getScopeOf = bind(this.getScopeOf, this);
      this.identifierWritten = bind(this.identifierWritten, this);
      this.identifierRead = bind(this.identifierRead, this);
      this.local = bind(this.local, this);
      this.symbols = Object.create(null);
      this.options = {};
      for (key in options) {
        if (!hasProp.call(options, key)) continue;
        value = options[key];
        this.options[key] = value;
      }
    }

    Scope.prototype.local = function(name, type) {
      if (type == null) {
        type = null;
      }
      if (!this.symbols[name]) {
        this.symbols[name] = {
          reads: [],
          writes: [],
          innerReads: [],
          innerWrites: [],
          type: type
        };
      }
      return this.symbols[name];
    };

    Scope.prototype.identifierRead = function(name, node) {
      this.local(name).reads.push(node);
      return void 0;
    };

    Scope.prototype.identifierWritten = function(name, node, type) {
      var ref;
      ref = this.local(name);
      ref.writes.push(node);
      if (ref.type == null) {
        ref.type = type;
      }
      return void 0;
    };

    Scope.prototype.getScopeOf = function(name) {
      if ((this.symbols[name] != null) && this.symbols[name].writes !== 0) {
        return this;
      } else {
        return this.parent.getScopeOf(name);
      }
    };

    Scope.prototype.commit = function() {
      var innerReads, innerWrites, name, reads, ref1, ref2, ref3, scope, type, writes;
      ref1 = this.symbols;
      for (name in ref1) {
        ref2 = ref1[name], reads = ref2.reads, writes = ref2.writes, type = ref2.type;
        if (type === "Argument") {
          continue;
        }
        scope = this.parent.getScopeOf(name);
        if (scope == null) {
          continue;
        }
        ref3 = scope.symbols[name], type = ref3.type, innerReads = ref3.innerReads, innerWrites = ref3.innerWrites;
        if (type === "Builtin" && writes.length) {
          continue;
        }
        Array.prototype.push.apply(innerReads, reads);
        Array.prototype.push.apply(innerWrites, writes);
        delete this.symbols[name];
      }
      return void 0;
    };

    Scope.prototype.appendErrors = function(errors) {
      var checkUsedBeforeDefined, comprehension, defined, innerReads, innerWrites, name, reads, ref1, ref2, type, writes;
      ref1 = this.symbols;
      for (name in ref1) {
        ref2 = ref1[name], reads = ref2.reads, writes = ref2.writes, type = ref2.type, innerReads = ref2.innerReads, innerWrites = ref2.innerWrites;
        if (!writes.length) {
          if (this.options["undefined"]) {
            (function() {
              var i, len, locationData, results;
              results = [];
              for (i = 0, len = reads.length; i < len; i++) {
                locationData = reads[i].locationData;
                results.push(errors.push({
                  lineNumber: locationData.first_line + 1,
                  message: "Undefined identifier \"" + name + "\""
                }));
              }
              return results;
            })();
          }
          continue;
        }
        defined = writes[0].locationData;
        comprehension = this.symbols[name].type === "Comprehension variable";
        checkUsedBeforeDefined = function(nodes) {
          var i, isBefore, len, locationData, results;
          isBefore = function(a, b) {
            return a.first_line < b.first_line || (a.first_line === b.first_line && a.first_column <= b.first_column);
          };
          results = [];
          for (i = 0, len = nodes.length; i < len; i++) {
            locationData = nodes[i].locationData;
            if (comprehension || !isBefore(locationData, defined)) {
              continue;
            }
            results.push(errors.push({
              lineNumber: locationData.first_line + 1,
              message: type + " \"" + name + "\" used before it was first defined (on line " + (defined.first_line + 1) + ", column " + (defined.first_column + 1) + ")"
            }));
          }
          return results;
        };
        if (!this.options["hoist_local"]) {
          checkUsedBeforeDefined(reads);
        }
        if (!this.options["hoist_parent"]) {
          checkUsedBeforeDefined(innerReads);
        }
        if (this.options["shadow"]) {
          (function(_this) {
            return (function(type, writes) {
              var exception, i, len, parent, ref3, ref4;
              if (type === "Builtin") {
                return;
              }
              parent = _this.parent.getScopeOf(name);
              if (parent == null) {
                return;
              }
              ref3 = parent.symbols[name], type = ref3.type, writes = ref3.writes;
              if (type === "Builtin" && !_this.options["shadow_builtins"]) {
                return;
              }
              ref4 = _this.options["shadow_exceptions"] || [];
              for (i = 0, len = ref4.length; i < len; i++) {
                exception = ref4[i];
                if ((new RegExp("^" + exception + "$")).test(name)) {
                  return;
                }
              }
              return errors.push({
                lineNumber: defined.first_line + 1,
                message: type === "Builtin" ? "Shadowing built-in identifier \"" + name + "\"" : "Shadowing " + type + " \"" + name + "\" (first defined on line " + (writes[0].locationData.first_line + 1) + ")"
              });
            });
          })(this)(type, writes);
        }
        if (((type === "Comprehension variable" || type === "Variable") && this.options["unused_variables"]) || type === "Class" && this.options["unused_classes"] || type === "Argument" && this.options["unused_arguments"]) {
          (function() {
            var i, index, len, locationData, ref3, results;
            if (reads.length || innerReads.length) {
              return;
            }
            ref3 = writes.concat(innerWrites);
            results = [];
            for (index = i = 0, len = ref3.length; i < len; index = ++i) {
              locationData = ref3[index].locationData;
              results.push(errors.push({
                lineNumber: locationData.first_line + 1,
                message: index ? type + " \"" + name + "\" is never used (first defined on line " + (defined.first_line + 1) + ")" : type + " \"" + name + "\" is never used"
              }));
            }
            return results;
          })();
        }
        if (this.options["overwrite"]) {
          (function(_this) {
            return (function() {
              var checkOverwrite;
              checkOverwrite = function(nodes) {
                var i, len, locationData, results;
                results = [];
                for (i = 0, len = nodes.length; i < len; i++) {
                  locationData = nodes[i].locationData;
                  results.push(errors.push({
                    lineNumber: locationData.first_line + 1,
                    message: "Overwriting " + type + " \"" + name + "\" (first defined on line " + (defined.first_line + 1) + ")"
                  }));
                }
                return results;
              };
              if (_this.options["same_scope"]) {
                checkOverwrite(writes.slice(1));
              }
              return checkOverwrite(innerWrites);
            });
          })(this)();
        }
      }
      return void 0;
    };

    return Scope;

  })();

}).call(this);
